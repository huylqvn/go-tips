## Algorithms:
### 1. **Problem Solving Strategies:**

#### a. Understand the Problem:

- Read and analyze the problem statement.
- Identify inputs, outputs, constraints, and requirements.

#### b. Plan the Solution:

- Break down the problem into smaller subproblems.
- Consider edge cases and constraints.
- Choose an appropriate algorithmic approach.

#### c. Pseudocode:

- Write pseudocode to outline the logic of your solution.
- Focus on the algorithm without worrying about syntax.

### 2. **Algorithmic Approaches:**

#### a. Brute Force:

- Consider all possibilities.
- Useful for small input sizes.

#### b. Divide and Conquer:

- Break the problem into smaller subproblems.
- Solve subproblems independently and combine solutions.

#### c. Dynamic Programming:

- Solve subproblems only once and store the results.
- Useful for optimization problems.

#### d. Greedy Algorithms:

- Make locally optimal choices at each stage.
- May not guarantee a globally optimal solution.

#### e. Backtracking:

- Systematically try all possibilities.
- Revert when a solution cannot be reached.

### 3. **Common Data Structures:**

#### a. Arrays:

- Sequential data storage.
- Access elements by index.

#### b. Linked Lists:

- Nodes linked together.
- Dynamic size.

#### c. Trees and Graphs:

- Hierarchical or interconnected structures.
- Various traversal and search algorithms.

#### d. Hash Tables:

- Key-value pairs.
- Efficient for lookup operations.

#### e. Stacks and Queues:

- LIFO (Last-In-First-Out) and FIFO (First-In-First-Out) structures.
- Useful for tracking state or managing order.

### 4. **Coding and Implementation:**

#### a. Choose the Right Language:

- Use a language you are comfortable with.

#### b. Follow Best Coding Practices:

- Write modular and readable code.
- Use meaningful variable and function names.

#### c. Test and Debug:

- Test your solution with various inputs.
- Debug and optimize for efficiency.

* Focus on common structures: arrays, linked lists, trees, graphs, hash tables, queues, and stacks.
* Arrays and Strings: Practice manipulating and searching.
* Linked Lists: Understand insertion, deletion, and reversal.
* Trees and Graphs: Study tree traversals, graph traversals, and common algorithms.
* Sorting and Searching: Know various algorithms and their time complexities.
* Dynamic Programming: Practice solving problems with optimal substructure and overlapping subproblems.
* Recursion and Backtracking: Understand the basics and practice problems.

* Optimization: Think about time and space complexity. Optimize your solutions.

## Method:

1. Brute Force:
* Idea: The simplest approach, trying all possibilities.
* Use Cases: Suitable for small input sizes; helps to understand the problem.
2. Two Pointers:
* Idea: Maintain two pointers to traverse the array, often used for searching, partitioning, or finding pairs.
* Use Cases: Sum of two elements, finding duplicates, or partitioning arrays.
3. Sliding Window:
* Idea: Maintain a subset (window) of elements as you iterate through the array, often used for finding subarrays or subsequences.
* Use Cases: Maximum sum subarray, minimum size subarray sum.
4. Hashing:
* Idea: Use a hash table or set to store and retrieve values efficiently.
* Use Cases: Finding duplicates, checking for anagrams, or frequency counting.
5. Sorting:
* Idea: Sort the array to simplify solving or finding patterns.
* Use Cases: Searching, finding duplicates, or detecting patterns.
6. Binary Search:
* Idea: Divide the array into two halves and eliminate one half of the elements based on a condition.
* Use Cases: Searching in a sorted array, finding peaks.
7. Dynamic Programming:
* Idea: Break down the problem into smaller subproblems and solve them. Store the solutions to subproblems to avoid redundant computation.
* Use Cases: Maximum subarray sum, longest increasing subsequence.
8. Greedy Algorithms:
* Idea: Make locally optimal choices at each stage with the hope of finding a global optimum.
* Use Cases: Activity selection, interval scheduling.
9. Prefix Sum:
* Idea: Precompute and store the cumulative sum of elements up to each index.
* Use Cases: Range sum queries, finding subarrays with a given sum.
10. Bit Manipulation:
* Idea: Use bitwise operations for certain types of problems.
* Use Cases: Single Number, Two's Complement.
11. Divide and Conquer:
* Idea: Divide the problem into smaller subproblems, solve them independently, and then combine the solutions.
* Use Cases: Merge Sort, Quick Sort.
12. Cyclic Sort:
* Idea: Iterate through the array and place each element in its correct position.
* Use Cases: Finding the first missing positive integer.
13. Kadane's Algorithm:
* Idea: Efficiently find the maximum subarray sum in a given array.
* Use Cases: Maximum subarray sum.
14. Reservoir Sampling:
* Idea: Randomly select a sample of k items from a stream of items.
* Use Cases: Random sampling.
15. Moore's Voting Algorithm:
* Idea: Find the majority element in an array.
* Use Cases: Finding the majority element.
